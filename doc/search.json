[
  {
    "objectID": "index.html#à-propos-de-ce-document",
    "href": "index.html#à-propos-de-ce-document",
    "title": "Introduction à la statistique bivariée avec R",
    "section": "À propos de ce document",
    "text": "À propos de ce document\nCe document est une introduction aux méthodes statistiques d’analyse bivariée et aux représentations graphiques avec le logicielR\nIl est basé sur R version 4.3.1 (2023-06-16).\nCe document est régulièrement corrigé et mis à jour. La version de référence est disponible en ligne à l’adresse :\n\nhttps://github.com/ClaudeGrasland/bivaR2023\n\nLe code source est disponible sur GitHub.\nPour toute suggestion ou correction, il est possible de me contacter par mail"
  },
  {
    "objectID": "index.html#remerciements",
    "href": "index.html#remerciements",
    "title": "Introduction à la statistique bivariée avec R",
    "section": "Remerciements",
    "text": "Remerciements\nCe document est rédigé en quarto à partir du modèle proposé par Julien Barnier dans son Introduction à R et au Tidyverse"
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "Introduction à la statistique bivariée avec R",
    "section": "Licence",
    "text": "Licence\nCe document est mis à disposition selon les termes de la Licence Creative Commons Attribution - Pas d’Utilisation Commerciale - Partage dans les Mêmes Conditions 4.0 International.\n\n\n\nLicence Creative Commons"
  },
  {
    "objectID": "01-PremierPas.html#opérations-arithmétiques",
    "href": "01-PremierPas.html#opérations-arithmétiques",
    "title": "1  Premier pas",
    "section": "1.1 Opérations arithmétiques",
    "text": "1.1 Opérations arithmétiques\nNous allons commencer par passer quelques commandes arithmétiques simples. Il suffit de les taper dans la console de R pour qu’elles s’executent automatiquement.\n\n8+2\n#&gt; [1] 10\n\n8-2\n#&gt; [1] 6\n\n8*2\n#&gt; [1] 16\n\n8/2\n#&gt; [1] 4\n\n8**2\n#&gt; [1] 64\n\n8**(1/2)\n#&gt; [1] 2.828427\n\nlog(10)\n#&gt; [1] 2.302585\n\nlog10(10)\n#&gt; [1] 1\n\nsqrt(10)\n#&gt; [1] 3.162278\n\nsin(pi)\n#&gt; [1] 0.0000000000000001224647\n\ncos(pi)\n#&gt; [1] -1\n\ntan(pi)\n#&gt; [1] -0.0000000000000001224647"
  },
  {
    "objectID": "01-PremierPas.html#les-objets-de-base-valeur-vecteur-matrice",
    "href": "01-PremierPas.html#les-objets-de-base-valeur-vecteur-matrice",
    "title": "1  Premier pas",
    "section": "1.2 Les objets de base : valeur, vecteur, matrice",
    "text": "1.2 Les objets de base : valeur, vecteur, matrice\nLes objets élémentéires de R apparaissent dans la fenêtre environnement sous la rubrique Values\n\n1.2.1 Eléments\nUn élément est unique et constitue la brique de base de tous les objets suivants. On peut aussi l’interpréter comme un vecteur de longueur 1 ou une matrice de dimension 1x1.\n\nx&lt;-8\ny&lt;-2\n\nx+y\n#&gt; [1] 10\nx*y\n#&gt; [1] 16\nx**y\n#&gt; [1] 64\n\nLes éléments se combinent différemment selon leur type. Par exemple, des éléments de type caractère (character) peuvent être assemblés avec l’instruction paste() ou découpez avec l’instruction substr() :\n\nx&lt;-\"Bonjour\"\ny&lt;- \"tout le monde\"\nz&lt;- \"!\"\npaste(x,y,z)\n#&gt; [1] \"Bonjour tout le monde !\"\nsubstr(x,1,3)\n#&gt; [1] \"Bon\"\n\nQuant aux éléments logiques (logical) nous verrons qu’ils peuvent se combiner avec des opérateurs comme & quii signifie ET ou bien | qui signifie OU.\n\nx&lt;-TRUE\ny&lt;-FALSE\n\nx & y\n#&gt; [1] FALSE\nx | y \n#&gt; [1] TRUE\n\n\n\n1.2.2 vecteurs (vectors)\nUn vecteur est un ensemble d’éléments de même type que l’on a concaténés à l’aide de l’instruction c(). On peut ensuite les aditionner, les multiplier ou les combiner avec des éléments.\n\nx &lt;- c(1,2,4,8,16)\ny &lt;- 4\nx+y\n#&gt; [1]  5  6  8 12 20\nx*y\n#&gt; [1]  4  8 16 32 64\nx**y\n#&gt; [1]     1    16   256  4096 65536\n\nOn remarque dans l’exemple ci-dessus que R n’a pas de problème pour combiner des vecteurs de tailles différentes.\n\n\n1.2.3 Matrices (matrix)\nUne matrice est un ensemble de vecteurs de même longueur et de même type. On peut donc construire une matrice en concaténant des vecteurs verticalement avec cbind()ou horizontalement avec rbind().\n\n\n# deux vecteurs\nx1 &lt;- c(1,2,4,8,16)\nx2 &lt;- c(5,10,15,20,25)\n\n# matrice en colonnes\nm1 &lt;- cbind(x1,x2)\nm1\n#&gt;      x1 x2\n#&gt; [1,]  1  5\n#&gt; [2,]  2 10\n#&gt; [3,]  4 15\n#&gt; [4,]  8 20\n#&gt; [5,] 16 25\n\n# matrice en lignes\nm2 &lt;- rbind(x1,x2)\nm2\n#&gt;    [,1] [,2] [,3] [,4] [,5]\n#&gt; x1    1    2    4    8   16\n#&gt; x2    5   10   15   20   25\n\n# piège !\nm3 &lt;- c(x1,x2)\nm3\n#&gt;  [1]  1  2  4  8 16  5 10 15 20 25\nis.matrix(m3)\n#&gt; [1] FALSE\n\n\n\n\nSi on assemble deux vecteurs à l’aide de la commande c()on obtient un vecteur et pas une matrice."
  },
  {
    "objectID": "01-PremierPas.html#ne-pas-confondre-listes-et-vecteurs",
    "href": "01-PremierPas.html#ne-pas-confondre-listes-et-vecteurs",
    "title": "1  Premier pas",
    "section": "1.3 Ne pas confondre listes et vecteurs !",
    "text": "1.3 Ne pas confondre listes et vecteurs !\nR utilise des types plus complexes d’objets qui lui sont propres et qui sont en général des listes ou des listes de listes.\n\nliste simple\nliste de liste\nlistes de vecteur = data.frame\n…\n\n\n\n\nLes vecteurs regroupent des éléments de même type tandis que les listes regroupent des éléments ou des objets de type quelconque. Le type liste est donc beaucoup plus général, mais aussi plus difficile d’emploi.\n\n\nOn peut comparer une liste à un panier de course dans lequel on mélange des choux, des carottes, des navets, une boîte de douze oeufs, un paquet de croquettes pour chiens, etc…\n\n\n\n\n# Format vecteur\nprenom &lt;- c(\"Ali\", \"Amine\",\n    \"Anne\",\"Marc\",\"Zayneb\")\nsexe &lt;- c(\"H\",\"H\",\"F\",\"H\",\"F\")\nage  &lt;- c(21,22,24,18,25)\n\n\n# Format liste\nAli &lt;- list(\"H\",21)\nAmine &lt;- list(\"F\",22)\nAnne &lt;- list(\"F\",28)\nMarc &lt;- list (\"H\",18)\nZayneb &lt;- list(\"F\",25)\n\n# Ne pas confondre !\nAli &lt;- c(\"H\",21)\nAli\n#&gt; [1] \"H\"  \"21\"\nAli &lt;- list(\"H\",21)\nAli\n#&gt; [[1]]\n#&gt; [1] \"H\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 21"
  },
  {
    "objectID": "01-PremierPas.html#attention-aux-types-de-variables",
    "href": "01-PremierPas.html#attention-aux-types-de-variables",
    "title": "1  Premier pas",
    "section": "1.4 Attention aux types de variables …",
    "text": "1.4 Attention aux types de variables …\nChaque valeur, vecteur ou matrice appartient à un seul type de données. Il est important de ne pas les confondre, sous peine d’obtenir des résultats … douteux. On se limitera ici aux principaux types, d’autres étant vus ultérieurement dans l’année :\n\nnumeric : type général (entier, réels, …)\nlogique : type booleen (TRUE/FALSE)\ndate : année, mois, jour,n heure, minutes, secondes, …\ncharacter : texte quelconque\nfactor : variable catégorielle (codage d’enquêtes …)\n\nLa commande str() permet de vérifier le type d’un vecteur (ou d’une matrice) et d’en afficher la dimension.\n\n# Format charactère\nprenom &lt;- c(\"Ali\", \"Amine\",\"Anne\",\n            \"Marc\",\"Zayneb\")\nstr(prenom)\n#&gt;  chr [1:5] \"Ali\" \"Amine\" \"Anne\" \"Marc\" \"Zayneb\"\n\n# Format logique\nlikeR &lt;- c(TRUE,FALSE, TRUE,\n           FALSE, FALSE)\nstr(likeR)\n#&gt;  logi [1:5] TRUE FALSE TRUE FALSE FALSE\n# Format Factor\nsexe &lt;- c(1,1,2,1,2)\nsexe&lt;-as.factor(sexe)\nlevels(sexe) &lt;-c(\"Homme\",\"Femme\")\nstr(sexe)\n#&gt;  Factor w/ 2 levels \"Homme\",\"Femme\": 1 1 2 1 2\n\n# Format numerique\nage  &lt;- c(21,22,24,18,25)\nstr(age)\n#&gt;  num [1:5] 21 22 24 18 25\n\n# Format date\nnais&lt;-c(\"1999-10-28\",\"1998-10-13\",\n \"1996-10-15\",\"2002-02-07\",\"1995-06-18\")\nnais&lt;-as.Date(nais)\nstr(nais)\n#&gt;  Date[1:5], format: \"1999-10-28\" \"1998-10-13\" \"1996-10-15\" \"2002-02-07\" \"1995-06-18\""
  },
  {
    "objectID": "01-PremierPas.html#types-de-tableaux-et-guerres-de-religion.",
    "href": "01-PremierPas.html#types-de-tableaux-et-guerres-de-religion.",
    "title": "1  Premier pas",
    "section": "1.5 Types de tableaux et guerres de religion.",
    "text": "1.5 Types de tableaux et guerres de religion.\nR est un langage qui a beaucouop évolué au cours du temps, suscitant l’apparition de nouveaux types d’objets mieux adapéts à certaines fonctions. Du coup, il existe plusieurs format de tableaux de données, plus ou moins compatibles entre eux.\nOn notera que dans la fenêtre environnement, les tableaux apparaissent dans la sous-fenêtre data et non plus dans la sous-fenêtre values comme c’était le cas pour les éléments, vecteurs ou matrices.\n\n1.5.1 Le type data.frame :\nC’est le type d’origine correspondant à ce qu’on appelle le langage R-Base. Il se présente en pratique comme une liste de vecteurs qui peuvent être de types différents mais qui sont de même longueur.\n\n# Création d'un data.frame\ntab1&lt;-data.frame(prenom,nais,\n                age,sexe,likeR)\nstr(tab1)\n#&gt; 'data.frame':    5 obs. of  5 variables:\n#&gt;  $ prenom: chr  \"Ali\" \"Amine\" \"Anne\" \"Marc\" ...\n#&gt;  $ nais  : Date, format: \"1999-10-28\" \"1998-10-13\" ...\n#&gt;  $ age   : num  21 22 24 18 25\n#&gt;  $ sexe  : Factor w/ 2 levels \"Homme\",\"Femme\": 1 1 2 1 2\n#&gt;  $ likeR : logi  TRUE FALSE TRUE FALSE FALSE\n\n\n\n1.5.2 Le type tibble\nc’est un type créé par Hadley Wickham pour développer la suite de fonctions Tidyverse ou ggplot\n\n# Création d'un tibble\nlibrary(tidyr, quiet=T)\ntab2&lt;-tibble(prenom,nais,\n            age,sexe,likeR)\nstr(tab2)\n#&gt; tibble [5 × 5] (S3: tbl_df/tbl/data.frame)\n#&gt;  $ prenom: chr [1:5] \"Ali\" \"Amine\" \"Anne\" \"Marc\" ...\n#&gt;  $ nais  : Date[1:5], format: \"1999-10-28\" \"1998-10-13\" ...\n#&gt;  $ age   : num [1:5] 21 22 24 18 25\n#&gt;  $ sexe  : Factor w/ 2 levels \"Homme\",\"Femme\": 1 1 2 1 2\n#&gt;  $ likeR : logi [1:5] TRUE FALSE TRUE FALSE FALSE\n\n\n\n1.5.3 Le type data.table\nC’est un type récent créé pour traiter les tableaux de très grande taille à l’aide du package … data.table\n\n\n# Création d'un data.table\nlibrary(data.table, quiet=T)\n#&gt; \n#&gt; Attaching package: 'data.table'\n#&gt; The following objects are masked from 'package:lubridate':\n#&gt; \n#&gt;     hour, isoweek, mday, minute, month, quarter, second, wday, week,\n#&gt;     yday, year\n#&gt; The following objects are masked from 'package:dplyr':\n#&gt; \n#&gt;     between, first, last\n#&gt; The following object is masked from 'package:purrr':\n#&gt; \n#&gt;     transpose\ntab3&lt;-data.table(prenom,nais,\n                age,sexe,likeR)\nstr(tab3)\n#&gt; Classes 'data.table' and 'data.frame':   5 obs. of  5 variables:\n#&gt;  $ prenom: chr  \"Ali\" \"Amine\" \"Anne\" \"Marc\" ...\n#&gt;  $ nais  : Date, format: \"1999-10-28\" \"1998-10-13\" ...\n#&gt;  $ age   : num  21 22 24 18 25\n#&gt;  $ sexe  : Factor w/ 2 levels \"Homme\",\"Femme\": 1 1 2 1 2\n#&gt;  $ likeR : logi  TRUE FALSE TRUE FALSE FALSE\n#&gt;  - attr(*, \".internal.selfref\")=&lt;externalptr&gt;"
  },
  {
    "objectID": "01-PremierPas.html#en-résumé",
    "href": "01-PremierPas.html#en-résumé",
    "title": "1  Premier pas",
    "section": "1.6 En résumé",
    "text": "1.6 En résumé\n\n\n\nR est un langage de programmation multifonction qui évolue depuis maintenant plus de 30 ans et auquel s’ajoutent continuellement de nouveaux packages. A la différence de SPSS, il n’est pas spécialisé uniquement en statistique, même si le coeur du logiciel est bien centré sur la statistique. Pour progresser rapidement en R il est indispensable :\n\n\n\nde prêter une grande attention aux types de variables et de tableaux.\n\n\nde ne pas chercher à utiliser trop vite de nouveaux packages tant que l’on n’a pas acquis une pratique suffisante du R-Base.\n\n\nde consulter la documentation et les forums de discussion en cas de difficulté."
  },
  {
    "objectID": "01-PremierPas.html#exercices",
    "href": "01-PremierPas.html#exercices",
    "title": "1  Premier pas",
    "section": "1.7 Exercices",
    "text": "1.7 Exercices\nExercice 1\nConstruire le vecteur x suivant :\n\n#&gt; [1] \"Paris\"    \"Londres\"  \"Tokyo\"    \"New York\"\n\n\n\nx &lt;- c(\"Paris\", \"Londres\",\"Tokyo\",\"New York\")\n\n\nConstruire le vecteur y suivant :\n\n#&gt; [1] \"France\"      \"Royaume-Uni\" \"Japon\"       \"USA\"\n\n\n\ny &lt;- c(\"France\", \"Royaume-Uni\",\"Japon\",\"USA\")\n\n\nConstruire le vecteur z suivant :\n\n#&gt; [1] 10.2 14.6 42.8 23.9\n\n\n\nz &lt;- c(10.2, 14.6,42.8,23.9)\n\n\nConstruire la matrice m1\n\n#&gt;   [,1]     [,2]          [,3]    [,4]      \n#&gt; x \"Paris\"  \"Londres\"     \"Tokyo\" \"New York\"\n#&gt; y \"France\" \"Royaume-Uni\" \"Japon\" \"USA\"\n\n\n\nm1&lt;-rbind(x,y)\n\n\nConstruire le data.frame df\n\n#&gt;             y        x    z\n#&gt; 1      France    Paris 10.2\n#&gt; 2 Royaume-Uni  Londres 14.6\n#&gt; 3       Japon    Tokyo 42.8\n#&gt; 4         USA New York 23.9\n\n\n\ndf&lt;-data.frame(y,x,z)\n\n\nExercice 2 (d’après J.Barnier)\nOn a demandé à 4 ménages le revenu des deux conjoints, et le nombre de personnes du ménage :\n\nconjoint1 &lt;- c(1200, 1180, 1750, 2100)\nconjoint2 &lt;- c(1450, 1870, 1690, 0)\nnb_personnes &lt;- c(4, 2, 3, 2)\n\nCalculer le revenu total de chaque ménage, puis diviser par le nombre de personnes pour obtenir le revenu par personne de chaque ménage.\n\n\nrevenu_total &lt;- conjoint1 + conjoint2\nrevenu_total / nb_personnes"
  },
  {
    "objectID": "02-OfficeKiller.html#rstudio-et-les-projets-r",
    "href": "02-OfficeKiller.html#rstudio-et-les-projets-r",
    "title": "2  Office Killer",
    "section": "2.1 Rstudio et les projets R",
    "text": "2.1 Rstudio et les projets R\n\n\nAu commencement, les dieux de la statistique créèrent le langage R.\nMais l’interface était vide et vague,\nles ténèbres couvraient les lignes de code\nR-Studio dit : Que le projet soit et le projet fut.\n\n\nSi l’on veut s’épargner bien des désagréments dans l’apprentissage de R, il faut prendre dès le départ de bonnes habitudes. Parmi celles-ci, l’une des plus importantes est le fait d’inscrire toujours son travail dans le cadre d’un projet R c’est-à-dire - en simplifiant beaucoup - un répertoire de travail contenant l’ensemble des données, programmes, résultats… que l’on pourra par la suite compresser, archiver et transmettre à quelqu’un d’autre.\n\n2.1.1 Lancement de R studio\nSauf à être complètement masochiste, on n’utilise jamais R directement mais on lance d’abord l’interface R-Studio qui facilite conisdérablement l’ensemble des opérations et offre une gamme considérable de services. Il ne faut toutefois pas confondre les deux et il serait par exemple ridicule d’indiquer sur un CV en vue d’un emploi de statisticien que l’on sait utiliser R-studio en oubliant de préciser que l’on maîtrise R.\n\n\n2.1.2 Création d’un projet\nPour créer un projet on utilise le menus déroulant File/new project/ … et on définit un dossier de notre ordinateur (existant ou à créer) qui contiendra le projet. Une fois l’opération effectuée, on pourra constater que ce dossier contient un fichier xxx.Rproj ou xxx est en principe le nom du dossier dans lequel vous avez stocké le projet.\nCe fichier contient toute une série d’informations dont nous ne parlerons pas dans ce cours d’initiation mais qui, pour faire simple, définissent un ensemble de réglages du logiciel et de préférences de l’utilisateur.\nSi vous fermez Rstudio (faites-le !) il vous suffira pour reprendre votre travail là où vous vous étiez arrêté :\n\nde lancer R-studio et de cliquer sur File/open project/… suivi du nom du fichier xxx.Rproj\nou plus simplement encore de double cliquer sur le fichier xxx.Rproj ce qui lancera automatiquement Rstudio\n\nLe dossier contenant votre projet R peut être organisé à votre convenance. Certains mettent tout les fichier pêle-mêle dans le dossier. D’autres préfèrent créer des sous-dossiers contenant des données, des programmes, des résultats, des figures. Vous déciderez à l’usage de ce qui vous convient le mieux, mais le point important est que tout ce qui entre ou sort de vos programmes R doit être de préférence stocké dans le répertoire du projet."
  },
  {
    "objectID": "02-OfficeKiller.html#programme-r-excel-killer",
    "href": "02-OfficeKiller.html#programme-r-excel-killer",
    "title": "2  Office Killer",
    "section": "2.2 Programme R : Excel killer ?",
    "text": "2.2 Programme R : Excel killer ?\n\n\nC’est pourquoi tu quittera Word et Excel, et t’attachera à R studio,\net vous deviendrez une seule chair.\n\n\nLa fonction initiale d’un langage de programmation comme R est … de créer des programmes c’est-à-dire des ensembles d’instruction permettant d’accomplir une tâche à l’intérieur d’une chaîne de production. Dans le cas d’un logiciel spécialisé dans l’analyse statistique, il s’agira donc de partir de données (statistiques, géographiques, textuelles, …) pour aboutir à des résultats prenant la forme de tableaux, cartes ou graphiques. Il ne s’agit donc en somme que d’une étape du travail de recherche où le principal avantage de R est d’automatiser une tâche et de faciliter sa reproduction ultérieure avec en arrière plan un objectif de productivité puisque l’ordinateur réalise en quelques millisecondes des tâches qui prendraient des heures avec un logiciel click-bouton de type Excel.\n\n\n\n\n\nPrenons un exemple simple de problème facile à résoudre avec R mais plus compliqué avec des logiciels click-boutons. Il s’agit d’un exemple pédagogique tiré d’un très vieux cours d’analyse spatiale portant sur les semis de point et les localisations optimales.\nOn considère une carte papier permettant de localiser 5 station services à l’intérieur d’une ville à plan en damier. Chaque station livre chacune la même quantité de carburant par semaine aux clients. On souhaite répondre aux questions suivantes :\n\nComment saisir les données dans une fichier numérique ?\nComment reproduire la carte papier sous forme d’un graphique ?\nComment calculer la dsitance à vol d’oiseau entre toutes les stations ?\nComment calculer la dsitance routière entre toutes les stations ?\nOù localiser un dépôt de carburant permettant d’alimenter les cinq stations en minimisant la distance moyenne de livraison (critère d’efficacite)\nOù localiser une caserne de pompier qui doit pouvoir intervenir rapidement sur toute les stations et qui doit minimiser la distance maximale à la station la plus éloignée (critère d’équité).\nComment visualiser ces deux localisations sur la carte des stations ?\nComment reproduire ces tâches rapidement s’il y a des ajouts ou suppressions de stations\n\n\n\n\n\n\nOn constitue deux équipes d’étudiants, certains utilisant un programme R et d’autres Excel. On se propose de voir qui ira le plus vite sur chacune des 8 tâches proposées.\n\n2.2.1 Round 1. Saisie des données et affichage du tableau\nOn crée un programme R avec File/New File/R Script puis on l’enregistre avec File/Save/ … suivi du nom du programme.\n\n# Saisie des variables\nCODE &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\")\nX &lt;- c(10,20,40,50,180)\nY &lt;- c(40,60,40,60,50)\n\n# Regroupement dans un tableau\ncoo &lt;- data.frame(X,Y)\n\n# Ajout du nom des lignes\nrow.names(coo) &lt;- CODE\n\n# Affichage du tableau\ncoo\n#&gt;     X  Y\n#&gt; A  10 40\n#&gt; B  20 60\n#&gt; C  40 40\n#&gt; D  50 60\n#&gt; E 180 50\n\nNormalement, les étudiants qui utilisent un tableur ont du aller plus vite et Excel mène sur R par 1-0\n\n\n2.2.2 Round 2. Affichage de la carte\nVous devez essayez de reproduire l’image correspondant au problème posé\n\nplot(X,Y, \n     col=\"red\", \n     pch=20, \n     xlim=c(0,180),\n     ylim=c(0,90),\n     asp = 1)\ntext(X,Y,\n     labels = CODE, \n     pos = 2)\n\n\n\n\nLa création d’un graphique est à première vue plus facile avec un logiciel click-bouton. L’avantage est très clairement pour Excel qui mène désormais 2 à 0.\n\n\n2.2.3 Round 3. Calcul de la station la plus accessible à vol d’oiseau (distance euclidienne)\nVous devez calculer une matrice de distance euclidienne entre toutes les stations et trouver la plus accessible.\n\n\n# calcul la matrice de distance euclidienne\nmat&lt;-dist(coo, upper = T, method = \"euclidean\")\nmat\n#&gt;           A         B         C         D         E\n#&gt; A            22.36068  30.00000  44.72136 170.29386\n#&gt; B  22.36068            28.28427  30.00000 160.31220\n#&gt; C  30.00000  28.28427            22.36068 140.35669\n#&gt; D  44.72136  30.00000  22.36068           130.38405\n#&gt; E 170.29386 160.31220 140.35669 130.38405\n\n# distance moyenne\napply(as.matrix(mat),1,mean)\n#&gt;         A         B         C         D         E \n#&gt;  53.47518  48.19143  44.20033  45.49322 120.26936\n\nLà, je parie que les utilisateurs d’Excel ont eu un peu plus de mal … En tous les cas, Excel ne mèneplus que par 2 à 1\n\n\n2.2.4 Round 4. Calcul de la station la plus accessible par la route (distance de Manhattan)\nVous devez calculer une matrice de distance de Manhattan entre toutes les stations et trouver la plus accessible.\n\n\n# calcul la matrice de distance de Manhattan\nmat&lt;-dist(coo,upper = T, method = \"manhattan\")\nmat\n#&gt;     A   B   C   D   E\n#&gt; A      30  30  60 180\n#&gt; B  30      40  30 170\n#&gt; C  30  40      30 150\n#&gt; D  60  30  30     140\n#&gt; E 180 170 150 140\n\n# distance moyenne de Manhattan\napply(as.matrix(mat),1,mean)\n#&gt;   A   B   C   D   E \n#&gt;  60  54  50  52 128\n\nJe reconnais que c’est unpeu facile, mais à nouveau R l’emporte ce qui fait désormais match nul 2-2\n\n\n2.2.5 Round 5. Localisation du dépôt de carburant\nDans le cas particulier de la distance de Manhattan, le calcul du point le plus proche de tous les autres s’obtient facilement en calculant le point médian dont les coordonnées correspondent à la médiane de X et la médiane de Y.\n\nmedX &lt;- median(X)\nmedX\n#&gt; [1] 40\nmedY &lt;- median(Y)\nmedY\n#&gt; [1] 50\n\nA priori, le calcul est aussi facile dans R et dans Excel : match nul 3-3\n\n\n2.2.6 Round 6. Localisation de la caserne de pompiers\nDans le cas particulier de la distance de Manhattan, le calcul du point minimisant la distance maximale s’obtient en trouvant le centre du diamètre minimal en X et en Y. Il s’agit de la localisation la plus équitable où le plus défavorisé est le moins défavorisé possible.\n\nequX &lt;- (max(X)+min(X))/2\nequX\n#&gt; [1] 95\nequY &lt;- (max(Y)+min(Y))/2\nequY\n#&gt; [1] 50\n\nA priori, le calcul est toujours aussi facile dans R et dans Excel : match nul 4-4\n\n\n2.2.7 Round 7. Visualisation des deux points sur la carte\nOn va placer en bleu le point médian et en vert le point le plus équitable. Dans le cas de R on peut recopier les lignes de code du graphique du round n°2 ce qui gagne désormais du temps :\n\n# Programme antérieur\nplot(X,Y, \n     col=\"red\", \n     pch=20, \n     xlim=c(0,180),\n     ylim=c(0,90),\n     asp = 1)\ntext(X,Y,\n     labels = CODE, \n     pos = 2)\n\n# Ajout du dépôt de carburant\npoints(medX, medY, col=\"blue\", pch=3)\ntext(medX,medY, \"dépot\",pos=1)\n\n# Ajout du point médian\npoints(equX, equY, col=\"green\", pch=3)\ntext(equX,equY, \"caserne\",pos=1)\n\n\n\n\nLe résultat du match est incertain mais R n’est plus désavantagé puisqu’on peut recycler les lignes de code précédentes pour le graphique de base. Disons 5-5 même s’il y a de fortes chances que R l’emporte.\n\n\n2.2.8 Dernier round. Refaire toute l’analyse avec une station de plus\nDeux stations F(100,20) et G(150,30) ont été ajoutées. Il faut refaire la carte finale. Cela ne pose aucun problème dans R puisqu’il suffit de modifier l’entrée des données et récupérer des bouts de programme\n\n# (1) Saisie des variables\nCODE &lt;- c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\")\nX &lt;- c(10,20,40,50,180,100,150)\nY &lt;- c(40,60,40,60,50,20,30)\ncoo &lt;- data.frame(X,Y)\nrow.names(coo) &lt;- CODE\n\n\n# (2) calcul des points centraux\nmedX &lt;- median(X)\nmedY &lt;- median(Y)\nequX &lt;- (max(X)+min(X))/2\nequY &lt;- (max(Y)+min(Y))/2\n\n\n# (3) Graphique\nplot(X,Y, \n     col=\"red\", \n     pch=20, \n     xlim=c(0,180),\n     ylim=c(0,90),\n     asp = 1)\ntext(X,Y,\n     labels = CODE, \n     pos = 2)\n\n# Ajout du dépôt de carburant\npoints(medX, medY, col=\"blue\", pch=3)\ntext(medX,medY, \"Dépôt\",pos=1)\n\n# Ajout du point médian\npoints(equX, equY, col=\"green\", pch=3)\ntext(equX,equY, \"Caserne\",pos=1)\n\n\n\n\nExcel n’a aucune chance d’aller plus vite et R remporte le match par KO !"
  },
  {
    "objectID": "02-OfficeKiller.html#document-rmd-word-killer",
    "href": "02-OfficeKiller.html#document-rmd-word-killer",
    "title": "2  Office Killer",
    "section": "2.3 Document Rmd : Word killer ?",
    "text": "2.3 Document Rmd : Word killer ?\n\n\nR-Studio dit : « Faisons une interface de rédaction adaptée à notre travail,\nQue l’utilisateur puissent y insérer les tableaux, les graphiques, les cartes, les références bibliographiques, et tous les écrits qui les commentent. »\n\n\nNous venons de voir comment une bonne pratique de R peut conduire progressivement à abandonner l’usage des tableurs (Excel, Open Office) sauf peut-être pour l’étape de saisie des données. Dès lors qu’il s’agit de réaliser des graphiques ou des calculs statistiques complexes, la rédaction d’un programme se révèle beaucoup plus intéressante même si elle impose un coût initial d’apprentissage.\nMais une bonne pratique de R ou plus précisément des documents R markdown peut vous conduire beaucoup plus loin et vous amener à abandonner également votre logiciel de traitement de texte (Word) et votre outil de présentation (Power Point). Le coût d’apprentissage est naturellement un peu plus élevé mais les bénéfices sont à la mesure de l’investissement.\nComme le montre la figure ci-dessous, un document R markdown est en quelques sorte un mélange entre des lignes de code R qui executent des tâches et des lignes de texte où sont expliqués les calculs et commentés les résultats obtenus. En d’autres termes, un document R markdown vous permet de rédiger un article de recherche complet, une présentation à une conférence, un syllabus de cours, dans un seul environnement logiciel (R studio).\nNul besoin de ciseau et de colle pour aller chercher tel tableau ici, tel figure là-bas ou telle carte ailleurs. Tous ces éléments sont intégrs au fur et à mesure de la rédaction ce qui facilite considérablement la concentration. Et surtout - on l’a déjà vu pour le programme R - le document peut facilement être reproduit ou mise à jour sans être obligé de réplique des dizaines de click de souris.\n\n\n\n\n\nNous allons illustrer l’usage de R markdown en rédigeant une courte note sur la distribution de la population et de certains commerces et services à Rennes. L’exemple est repris du Manuel d’analyse spatiale publié par l’INSEE en 2018 et plus précisement de son chapitre 4. Les configurations de points\nComme nous avons pris la perspective de n’employer aucun package R au cours de cette formation initiale, les données ont été légèrement modifiées, notamment pour le tracé de la carte des contours de la ville de Rennes.\n\n2.3.1 Chargement des données\nNous disposons de trois fichiers qui comportent chacun des coordonnées de localisation utilisant la même projection Lambert et que l’on pourra de ce fait superposer. Après les avoir chargés et décrits, on en propose une première visualisation à l’aide des fonctions graphiques de base de R.\n\n\n2.3.2 Contour de Rennes\nOn charge le fichier avec read.table() puis on affiche ses premières lignes avec head()et on regarde sa taille avec dim()\n\nmap &lt;- read.table(file = \"resources/data/rennes/map.csv\",\n                  header = T,\n                  sep = \";\")\nhead(map,2)\n#&gt;          x       y\n#&gt; 1 346382.1 6786334\n#&gt; 2 346460.0 6786704\ndim(map)\n#&gt; [1] 37  2\n\nOn affiche le contour avec les instructions plot() et lines(). On doit impérativement ajouter le paramètre asp = 1 dans plot() pour imposer une échelle identique sur l’axe vertical et l’axe horizontal.\n\nplot(map$x,map$y, col=\"red\", asp = 1)\nlines(map$x,map$y, col=\"blue\")\n\n\n\n\n\n\n2.3.3 Distribution de la population\nOn charge le fichier de population de la même manière et on constate qu’il comporte une troisième colonne indiquant la population localisée en chaque point. En fait, il s’agit d’une grille de population qui localise les habitants sur une maille de ??? m\n\npop &lt;- read.table(file = \"resources/data/rennes/popu.csv\",\n                  header = T,\n                  sep = \";\")\nhead(pop,2)\n#&gt;          x       y pop\n#&gt; 1 346202.1 6790631  20\n#&gt; 2 346203.4 6792843   5\ndim(pop)\n#&gt; [1] 24916     3\n\nOn procède à une première cartographie qui ne tient pas compte de l’effectif de population mais indique juste les cases occupées et inoccupées, ce qui permet de donner une vision générale de l’occuparion du sol et du peuplement de Rennes et de l’espace environnant.\n\nplot(pop$x,pop$y, col=\"red\", asp = 1,pch=22, cex=0.01)\nlines(map$x,map$y, col=\"black\")\n\n\n\n\n\n\n2.3.4 Distribution des équipements\nL’INSEE a extrait du fichier de la Base Publique des Equipements quatre types de localisations correspondant aux écoles, aux médecins, aux pharmacies et aux commerces de vêtements. On notera l’ajout du paramètre encoding=“UTF-8” qui permet de lire sans erreur les caractères accentués et d’éviter par exemple que “Vêtements” devienne “VÃªtements”.\n\nbpe &lt;- read.table(file = \"resources/data/rennes/bpe.csv\",\n                  header = T,\n                  sep = \";\",\n                  encoding=\"UTF-8\")\nhead(bpe,2)\n#&gt;            x       y    equ\n#&gt; 286 349156.2 6790525 Ecoles\n#&gt; 287 351800.4 6786774 Ecoles\ndim(bpe)\n#&gt; [1] 767   3\n\nOn utilise l’instruction table()pour dénombrer l’effectif de chaque équipement :\n\ntable(bpe$equ)\n#&gt; \n#&gt;     Ecoles   Médecins Pharmacies  Vêtements \n#&gt;         59        268         70        370\n\nPuis on visualise après avoir attribué une couleur à chaque équipement. On crée pour cela une nouvelle variable :\n\nbpe$couleur&lt;-as.factor(bpe$equ)\nlevels(bpe$couleur)\n#&gt; [1] \"Ecoles\"     \"Médecins\"   \"Pharmacies\" \"Vêtements\"\nlevels(bpe$couleur)&lt;-c(\"blue\",\"green\",\"orange\",\"red\")\nbpe$couleur&lt;-as.character(bpe$couleur)\ntable(bpe$couleur)\n#&gt; \n#&gt;   blue  green orange    red \n#&gt;     59    268     70    370\n\n\n\n2.3.5 Synthèse\nOn peut désormais assembler nos trois couches :\n\nplot(pop$x,pop$y, col=\"gray\", asp = 1,pch=22, cex=0.01)\nlines(map$x,map$y, col=\"black\")\npoints(bpe$x,bpe$y,bg=bpe$couleur, pch=21, cex=0.8)\n\n\n\n\nIl est facile de procéder à un zoom en ajoutant des paramètres xlim et ylim dans la fonction plot() qui précise l’espace d’étude.\n\nplot(pop$x,\n     pop$y, \n     col=\"gray\", \n     asp = 1,\n     pch=22, \n     cex=0.1,\n     xlim = c(351000,353000),\n     ylim = c(6788500,6790500))\n\nlines(map$x,\n      map$y, \n      col=\"black\")\n\npoints(bpe$x,\n       bpe$y,\n       bg=bpe$couleur, \n       pch=21, \n       cex=0.8)\n\n\n\n\nOK, notre carte n’a pas de légende (c’est possible mais vraiment compliqué en R-Base) mais on appréciera le fait d’avoir pu la réaliser en ne se servant que de quelques fonctions élémentaires de R comme"
  },
  {
    "objectID": "02-OfficeKiller.html#diapos-rmd-power-point-killer",
    "href": "02-OfficeKiller.html#diapos-rmd-power-point-killer",
    "title": "2  Office Killer",
    "section": "2.4 Diapos Rmd : Power Point killer",
    "text": "2.4 Diapos Rmd : Power Point killer\nLorsque l’on crée un fichier Markdown, on peut décider qu’il ne s’agit pas d’un document mais d’une présentation et opter pour l’un des deux modes par défaut appelés slidy et ioslides.\n\n\n\n\n\nOn peut ensuite créer un diaporama en donnant un titre général et en séparant chaque diapo par un titre de niveau 2 correspondant à des lignes débutant par ## comme dans l’exemple ci-dessous :\n\n\n\n\n\nIl ne reste plus qu’à compiler le programme avec l’icône Knit (pelotte de laine) pour générer un document .html en forme de dipositives."
  },
  {
    "objectID": "02-OfficeKiller.html#en-résumé",
    "href": "02-OfficeKiller.html#en-résumé",
    "title": "2  Office Killer",
    "section": "2.5 En résumé",
    "text": "2.5 En résumé\n\n\n\nR est un Excel killer mais aussi un Word killer voire un Power point killer… Adopter R peut nuire gravement à vos habitudes antérieures de travail."
  },
  {
    "objectID": "03-Base.html#tableaux",
    "href": "03-Base.html#tableaux",
    "title": "3  R-Base",
    "section": "3.1 Tableaux",
    "text": "3.1 Tableaux\n\n3.1.1 Importation\n\n3.1.1.1 Localisation des fichiers\n\nLa commande getwd() permet de connaître la position du répertoire courant. Si vous avez ouvert un projet (ce qui est vivement recommandé) la localisation est l’emplacement du fichier .Rproj.\n\n\ngetwd() \n#&gt; [1] \"/Users/claudegrasland1/git/bivar2023\"\n\n\nLa commande list.files() permet d’examiner le contenu du répertoire courant\n\n\nlist.files()\n#&gt;  [1] \"_extensions\"         \"_freeze\"             \"_quarto.yml\"        \n#&gt;  [4] \"_setup.qmd\"          \"01-PremierPas.qmd\"   \"02-OfficeKiller.qmd\"\n#&gt;  [7] \"03-Base.qmd\"         \"03-Base.rmarkdown\"   \"22-ressources.qmd\"  \n#&gt; [10] \"bivar2023.Rproj\"     \"css\"                 \"DESCRIPTION\"        \n#&gt; [13] \"doc\"                 \"index.qmd\"           \"js\"                 \n#&gt; [16] \"latex\"               \"LICENSE\"             \"README.md\"          \n#&gt; [19] \"resources\"\n\n\n\n3.1.1.2 Chargement d’un fichier texte\n\nAvec la souris\n\nCliquer sur les menus déroulants File/Import Dataset/From text (base) puis suivre le menu\n\n\n\n\n\n\nAvec des lignes de code\n\nOn utilise par exemple la fonction read.table() en précisant les paramètres utiles :\n\neuro1988 &lt;- read.table(file = \"resources/data/europe88/euro1988.csv\", # nom du fichier et chemin d'accès\n                  sep = \";\",                     # séparateur (ici, des points-virgule)\n                  header = TRUE,                 # ligne d'en-tête avec le nom des variables\n                  encoding=\"UTF-8\")              # encodage adapté au français\n\n\n\n3.1.1.3 Dimensions d’un tableau\n\nLa fonction dim() fournit les dimensions d’un tableau\n\n\ndim(euro1988)\n#&gt; [1] 25 15\n\n\nLa fonction class() fournit le type d’un tableau\n\n\nclass(euro1988)\n#&gt; [1] \"data.frame\"\n\n\n\n3.1.1.4 Visualisation du contenu d’un tableau\n\nPremières lignes avec head()\n\n\nhead(euro1988)         # Affiche par défaut les 6 premières lignes\n#&gt;   PAYS BLOC   PNB  TMI ESP URB NAT MOR FEC JEU VIE SUP  POP       X       Y\n#&gt; 1  ALB  Soc   600 43.0  71  34  27   6 3.3  35   5  29  3.1 4825115 1684833\n#&gt; 2  AUT  Cap 10000 10.3  75  55  12  12 1.4  18  14  84  7.6 4299715 2335579\n#&gt; 3  BEL  Cap  9200  9.7  75  95  12  11 1.5  19  14  31  9.9 3636312 2667243\n#&gt; 4  BGR  Soc  2000 14.5  72  65  13  11 2.0  21  11 111  9.0 5206070 1930219\n#&gt; 5  CHE  Cap 17800  6.8  77  61  12   9 1.5  17  14  41  6.6 3869378 2243130\n#&gt; 6  CSK  Soc  3200 13.9  71  74  14  12 2.0  24  11 128 15.6 4487005 2540281\n\n\nDernières lignes avec tail()\n\n\ntail(euro1988,2)         # Affiche les 2 dernières lignes\n#&gt;    PAYS BLOC   PNB  TMI ESP URB NAT MOR FEC JEU VIE SUP  POP       X       Y\n#&gt; 24  SWE  Cap 13200  5.9  77  83  12  11 1.8  18  18 450  8.4 4321587 3961396\n#&gt; 25  YUG  Soc  2300 27.1  70  47  15   8 2.1  24   8 256 23.6 4686147 1996737\n\n\n\n3.1.1.5 Verification des variables\n\nVérifie le type avec str()\n\n\nstr(euro1988)\n#&gt; 'data.frame':    25 obs. of  15 variables:\n#&gt;  $ PAYS: chr  \"ALB\" \"AUT\" \"BEL\" \"BGR\" ...\n#&gt;  $ BLOC: chr  \"Soc\" \"Cap\" \"Cap\" \"Soc\" ...\n#&gt;  $ PNB : int  600 10000 9200 2000 17800 3200 3700 12000 12600 4800 ...\n#&gt;  $ TMI : num  43 10.3 9.7 14.5 6.8 13.9 9.2 8.6 8.4 9 ...\n#&gt;  $ ESP : int  71 75 75 72 77 71 72 75 75 76 ...\n#&gt;  $ URB : int  34 55 95 65 61 74 77 94 84 91 ...\n#&gt;  $ NAT : int  27 12 12 13 12 14 13 10 11 12 ...\n#&gt;  $ MOR : int  6 12 11 11 9 12 13 11 11 8 ...\n#&gt;  $ FEC : num  3.3 1.4 1.5 2 1.5 2 1.7 1.4 1.5 1.7 ...\n#&gt;  $ JEU : int  35 18 19 21 17 24 19 15 18 23 ...\n#&gt;  $ VIE : int  5 14 14 11 14 11 14 15 15 12 ...\n#&gt;  $ SUP : int  29 84 31 111 41 128 108 248 43 505 ...\n#&gt;  $ POP : num  3.1 7.6 9.9 9 6.6 15.6 16.6 61.2 5.1 39 ...\n#&gt;  $ X   : num  4825115 4299715 3636312 5206070 3869378 ...\n#&gt;  $ Y   : num  1684833 2335579 2667243 1930219 2243130 ...\n\n\nRecode avec les fonctions as.xxx()\n\n\neuro1988$BLOC&lt;-as.factor(euro1988$PAYS)\nstr(euro1988)\n#&gt; 'data.frame':    25 obs. of  15 variables:\n#&gt;  $ PAYS: chr  \"ALB\" \"AUT\" \"BEL\" \"BGR\" ...\n#&gt;  $ BLOC: Factor w/ 25 levels \"ALB\",\"AUT\",\"BEL\",..: 1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ PNB : int  600 10000 9200 2000 17800 3200 3700 12000 12600 4800 ...\n#&gt;  $ TMI : num  43 10.3 9.7 14.5 6.8 13.9 9.2 8.6 8.4 9 ...\n#&gt;  $ ESP : int  71 75 75 72 77 71 72 75 75 76 ...\n#&gt;  $ URB : int  34 55 95 65 61 74 77 94 84 91 ...\n#&gt;  $ NAT : int  27 12 12 13 12 14 13 10 11 12 ...\n#&gt;  $ MOR : int  6 12 11 11 9 12 13 11 11 8 ...\n#&gt;  $ FEC : num  3.3 1.4 1.5 2 1.5 2 1.7 1.4 1.5 1.7 ...\n#&gt;  $ JEU : int  35 18 19 21 17 24 19 15 18 23 ...\n#&gt;  $ VIE : int  5 14 14 11 14 11 14 15 15 12 ...\n#&gt;  $ SUP : int  29 84 31 111 41 128 108 248 43 505 ...\n#&gt;  $ POP : num  3.1 7.6 9.9 9 6.6 15.6 16.6 61.2 5.1 39 ...\n#&gt;  $ X   : num  4825115 4299715 3636312 5206070 3869378 ...\n#&gt;  $ Y   : num  1684833 2335579 2667243 1930219 2243130 ...\n\n\n\n3.1.1.6 Résume du tableau\nLa fonction summary() donne un aperçu général des variables\n\nsummary(euro1988)\n#&gt;      PAYS                BLOC         PNB             TMI       \n#&gt;  Length:25          ALB    : 1   Min.   :  600   Min.   : 5.80  \n#&gt;  Class :character   AUT    : 1   1st Qu.: 2300   1st Qu.: 8.50  \n#&gt;  Mode  :character   BEL    : 1   Median : 8600   Median : 9.70  \n#&gt;                     BGR    : 1   Mean   : 7580   Mean   :12.99  \n#&gt;                     CHE    : 1   3rd Qu.:12000   3rd Qu.:14.50  \n#&gt;                     CSK    : 1   Max.   :17800   Max.   :43.00  \n#&gt;                     (Other):19                                  \n#&gt;       ESP             URB             NAT            MOR             FEC       \n#&gt;  Min.   :70.00   Min.   :30.00   Min.   :10.0   Min.   : 6.00   Min.   :1.400  \n#&gt;  1st Qu.:72.00   1st Qu.:58.00   1st Qu.:12.0   1st Qu.: 9.00   1st Qu.:1.500  \n#&gt;  Median :75.00   Median :71.00   Median :12.0   Median :11.00   Median :1.700  \n#&gt;  Mean   :73.72   Mean   :68.44   Mean   :13.4   Mean   :10.36   Mean   :1.816  \n#&gt;  3rd Qu.:75.00   3rd Qu.:83.00   3rd Qu.:14.0   3rd Qu.:11.00   3rd Qu.:2.000  \n#&gt;  Max.   :77.00   Max.   :95.00   Max.   :27.0   Max.   :14.00   Max.   :3.300  \n#&gt;                                                                                \n#&gt;       JEU             VIE             SUP             POP       \n#&gt;  Min.   :15.00   Min.   : 5.00   Min.   :  3.0   Min.   : 0.40  \n#&gt;  1st Qu.:19.00   1st Qu.:11.00   1st Qu.: 70.0   1st Qu.: 6.60  \n#&gt;  Median :19.00   Median :13.00   Median :128.0   Median :10.30  \n#&gt;  Mean   :21.16   Mean   :12.52   Mean   :190.7   Mean   :19.83  \n#&gt;  3rd Qu.:23.00   3rd Qu.:14.00   3rd Qu.:301.0   3rd Qu.:23.60  \n#&gt;  Max.   :35.00   Max.   :18.00   Max.   :551.0   Max.   :61.20  \n#&gt;                                                                 \n#&gt;        X                 Y          \n#&gt;  Min.   :2498763   Min.   :1535337  \n#&gt;  1st Qu.:3713871   1st Qu.:1996737  \n#&gt;  Median :4166231   Median :2540281  \n#&gt;  Mean   :4091984   Mean   :2572739  \n#&gt;  3rd Qu.:4686147   3rd Qu.:2851709  \n#&gt;  Max.   :5206070   Max.   :4230412  \n#&gt; \n\n\n\n\n3.1.2 Transformations\n\n3.1.2.1 Copie intégrale\nElle s’effectue avec l’opérateur &lt;-\n\ntab&lt;-euro1988\ndim(tab)\n#&gt; [1] 25 15\nhead(tab,2)\n#&gt;   PAYS BLOC   PNB  TMI ESP URB NAT MOR FEC JEU VIE SUP POP       X       Y\n#&gt; 1  ALB  ALB   600 43.0  71  34  27   6 3.3  35   5  29 3.1 4825115 1684833\n#&gt; 2  AUT  AUT 10000 10.3  75  55  12  12 1.4  18  14  84 7.6 4299715 2335579\ntail(tab,2)\n#&gt;    PAYS BLOC   PNB  TMI ESP URB NAT MOR FEC JEU VIE SUP  POP       X       Y\n#&gt; 24  SWE  SWE 13200  5.9  77  83  12  11 1.8  18  18 450  8.4 4321587 3961396\n#&gt; 25  YUG  YUG  2300 27.1  70  47  15   8 2.1  24   8 256 23.6 4686147 1996737\n\n\n\n3.1.2.2 Sélection de lignes\nOn utilise la syntaxe tab2&lt;-tab[conditions , ] avec les opérateurs logiques suivants\n\n== : est égal à\n!= : est différent de\n&gt;  : est strictement supérieur à\n&lt;  : est strictement inférieur à\n&gt;= : est supérieur ou égal à\n&lt;= : est inférieur ou égal à\n\n& : ET (vrai si les deux conditions sont vérifiées)\n| : OU inclusif (vrai si l’une des conditions est vérifiée)\nxor : OU exclusif (vrai si une seule des conditions est vérifiée)\nExemple de sélection des pays socialistes\n\n\ntabsoc&lt;-euro1988[euro1988$BLOC==\"Soc\",]\ntabsoc\n#&gt;  [1] PAYS BLOC PNB  TMI  ESP  URB  NAT  MOR  FEC  JEU  VIE  SUP  POP  X    Y   \n#&gt; &lt;0 rows&gt; (or 0-length row.names)\n\n\nExemple de sélection des pays non socialistes\n\n\ntabcap&lt;-euro1988[euro1988$BLOC!=\"Soc\",]\ntabcap\n#&gt;    PAYS BLOC   PNB  TMI ESP URB NAT MOR FEC JEU VIE SUP  POP       X       Y\n#&gt; 1   ALB  ALB   600 43.0  71  34  27   6 3.3  35   5  29  3.1 4825115 1684833\n#&gt; 2   AUT  AUT 10000 10.3  75  55  12  12 1.4  18  14  84  7.6 4299715 2335579\n#&gt; 3   BEL  BEL  9200  9.7  75  95  12  11 1.5  19  14  31  9.9 3636312 2667243\n#&gt; 4   BGR  BGR  2000 14.5  72  65  13  11 2.0  21  11 111  9.0 5206070 1930219\n#&gt; 5   CHE  CHE 17800  6.8  77  61  12   9 1.5  17  14  41  6.6 3869378 2243130\n#&gt; 6   CSK  CSK  3200 13.9  71  74  14  12 2.0  24  11 128 15.6 4487005 2540281\n#&gt; 7   DDR  DDR  3700  9.2  72  77  13  13 1.7  19  14 108 16.6 4166231 2825762\n#&gt; 8   DEU  DEU 12000  8.6  75  94  10  11 1.4  15  15 248 61.2 3962835 2640209\n#&gt; 9   DNK  DNK 12600  8.4  75  84  11  11 1.5  18  15  43  5.1 3958433 3234283\n#&gt; 10  ESP  ESP  4800  9.0  76  91  12   8 1.7  23  12 505 39.0 2875285 1646307\n#&gt; 11  FIN  FIN 12200  5.8  74  62  12  10 1.6  19  13 337  4.9 4774974 4230412\n#&gt; 12  FRA  FRA 10100  8.0  75  73  14  10 1.8  21  13 551 55.9 3441707 2245325\n#&gt; 13  GBR  GBR  8900  9.5  75  91  13  12 1.8  19  15 245 57.1 3212580 3065463\n#&gt;  [ reached 'max' / getOption(\"max.print\") -- omitted 12 rows ]\n\n\nExemple de sélection des pays de plus 10 millions d’habitant\n\n\ntabbig&lt;-euro1988[euro1988$POP&gt;20,]\ntabbig\n#&gt;    PAYS BLOC   PNB  TMI ESP URB NAT MOR FEC JEU VIE SUP  POP       X       Y\n#&gt; 8   DEU  DEU 12000  8.6  75  94  10  11 1.4  15  15 248 61.2 3962835 2640209\n#&gt; 10  ESP  ESP  4800  9.0  76  91  12   8 1.7  23  12 505 39.0 2875285 1646307\n#&gt; 12  FRA  FRA 10100  8.0  75  73  14  10 1.8  21  13 551 55.9 3441707 2245325\n#&gt; 13  GBR  GBR  8900  9.5  75  91  13  12 1.8  19  15 245 57.1 3212580 3065463\n#&gt; 17  ITA  ITA  8600 10.1  75  72  10  10 1.4  19  13 301 57.3 4184347 1884241\n#&gt; 21  POL  POL  2100 17.5  71  61  17  10 2.2  26   9 313 38.0 4622269 2851709\n#&gt; 23  ROU  ROU  1200 25.6  70  49  16  11 2.3  25   9 238 23.0 5120263 2251425\n#&gt; 25  YUG  YUG  2300 27.1  70  47  15   8 2.1  24   8 256 23.6 4686147 1996737\n\n\nExemple de sélection des pays socialistes de plus 20 millions d’habitant (on mélange deux conditions avec l’opérateur &)\n\n\ntabsocbig&lt;-euro1988[euro1988$BLOC==\"Soc\" & euro1988$POP&gt;20,]\ntabsocbig\n#&gt;  [1] PAYS BLOC PNB  TMI  ESP  URB  NAT  MOR  FEC  JEU  VIE  SUP  POP  X    Y   \n#&gt; &lt;0 rows&gt; (or 0-length row.names)\n\n\n\n3.1.2.3 Sélection de colonnes\nOn utilise la syntaxe tab2&lt;-tab[  ,  liste ] avec différentes syntaxes pour les listes de variables :\n\nSélection nominale\n\n\ntab&lt;-euro1988[,c(\"PAYS\", \"BLOC\", \"PNB\", \"TMI\",\"POP\")]\nhead(tab,2)\n#&gt;   PAYS BLOC   PNB  TMI POP\n#&gt; 1  ALB  ALB   600 43.0 3.1\n#&gt; 2  AUT  AUT 10000 10.3 7.6\n\n\nSélection de positions\n\n\ntab&lt;-euro1988[,c(1:4, 13)]\nhead(tab,2)\n#&gt;   PAYS BLOC   PNB  TMI POP\n#&gt; 1  ALB  ALB   600 43.0 3.1\n#&gt; 2  AUT  AUT 10000 10.3 7.6\n\n\n\n3.1.2.4 Sélection simultanée de lignes et colonnes\nOn utilise la syntaxe tab2&lt;-tab[ conditions ,  liste]\n\nExemple : PNB et BLOC des pays de moins de 5 millions d’habitant\n\n\ntab&lt;-euro1988[euro1988$POP&lt;5, c(\"PAYS\",\"BLOC\",\"POP\",\"PNB\")]\ntab\n#&gt;    PAYS BLOC POP   PNB\n#&gt; 1   ALB  ALB 3.1   600\n#&gt; 11  FIN  FIN 4.9 12200\n#&gt; 16  IRL  IRL 3.5  5100\n#&gt; 18  LUX  LUX 0.4 16500\n#&gt; 20  NOR  NOR 4.2 15500\n\n\n\n\n3.1.3 Extractions\n\n3.1.3.1 Extraction d’une Variable = Vecteur\n\nSolution n°1 : utilisation de l’opérateur $\n\n\nmyvar&lt;-euro1988$POP\nstr(myvar)\n#&gt;  num [1:25] 3.1 7.6 9.9 9 6.6 15.6 16.6 61.2 5.1 39 ...\nmean(myvar)\n#&gt; [1] 19.828\n\n-Solution n°2 : utilisation de [ , ]\n\nmyvar&lt;-euro1988[,13]\nstr(myvar)\n#&gt;  num [1:25] 3.1 7.6 9.9 9 6.6 15.6 16.6 61.2 5.1 39 ...\nmean(myvar)\n#&gt; [1] 19.828\n\n\n\n3.1.3.2 Création d’une matrice\nOn sélectionne les lignes et les colonnes puis on convertit en matrice avec l’instruction as.matrix(). Attention, les variables doivent être de même type (toutes numériques ou toutes caractère ou …), sinon R effectue une conversion forcée.\n\nExemple 1 : création d’une matrice de corrélation\n\nOn commence par extraire trois variables du tableau pour en faire une matrice :\n\nmymat&lt;-euro1988[,c(\"PNB\",\"TMI\",\"FEC\")]\nrow.names(mymat)&lt;-euro1988$PAYS  # facultatif : donne le nom des lignes\nstr(mymat)\n#&gt; 'data.frame':    25 obs. of  3 variables:\n#&gt;  $ PNB: int  600 10000 9200 2000 17800 3200 3700 12000 12600 4800 ...\n#&gt;  $ TMI: num  43 10.3 9.7 14.5 6.8 13.9 9.2 8.6 8.4 9 ...\n#&gt;  $ FEC: num  3.3 1.4 1.5 2 1.5 2 1.7 1.4 1.5 1.7 ...\nmymat&lt;-as.matrix(mymat)\nstr(mymat)\n#&gt;  num [1:25, 1:3] 600 10000 9200 2000 17800 3200 3700 12000 12600 4800 ...\n#&gt;  - attr(*, \"dimnames\")=List of 2\n#&gt;   ..$ : chr [1:25] \"ALB\" \"AUT\" \"BEL\" \"BGR\" ...\n#&gt;   ..$ : chr [1:3] \"PNB\" \"TMI\" \"FEC\"\n\nPuis on applique la fonction cor() à cette matrice pour en faire une matrice de corrélation ;\n\nmycor&lt;-cor(mymat)\nmycor\n#&gt;            PNB        TMI        FEC\n#&gt; PNB  1.0000000 -0.6584308 -0.6144008\n#&gt; TMI -0.6584308  1.0000000  0.8136871\n#&gt; FEC -0.6144008  0.8136871  1.0000000\nstr(mycor)\n#&gt;  num [1:3, 1:3] 1 -0.658 -0.614 -0.658 1 ...\n#&gt;  - attr(*, \"dimnames\")=List of 2\n#&gt;   ..$ : chr [1:3] \"PNB\" \"TMI\" \"FEC\"\n#&gt;   ..$ : chr [1:3] \"PNB\" \"TMI\" \"FEC\"\n\n\nExemple 2 : Création d’une matrice de distance\n\nOn commence par extraire les coordonnées (X,Y) sous forme de matrice\n\nmatcoo&lt;-as.matrix(euro1988[,c(\"X\",\"Y\")])\nrow.names(matcoo)&lt;-euro1988$PAYS  # facultatif : donne le nom des lignes\nstr(matcoo)\n#&gt;  num [1:25, 1:2] 4825115 4299715 3636312 5206070 3869378 ...\n#&gt;  - attr(*, \"dimnames\")=List of 2\n#&gt;   ..$ : chr [1:25] \"ALB\" \"AUT\" \"BEL\" \"BGR\" ...\n#&gt;   ..$ : chr [1:2] \"X\" \"Y\"\nhead(matcoo)\n#&gt;           X       Y\n#&gt; ALB 4825115 1684833\n#&gt; AUT 4299715 2335579\n#&gt; BEL 3636312 2667243\n#&gt; BGR 5206070 1930219\n#&gt; CHE 3869378 2243130\n#&gt; CSK 4487005 2540281\n\nPuis on transforme ces coordonnées en distance à l’aide de la fonction dist()\n\nmatdis&lt;-as.matrix(dist(matcoo))\nstr(matdis)\n#&gt;  num [1:25, 1:25] 0 836370 1542200 453145 1106855 ...\n#&gt;  - attr(*, \"dimnames\")=List of 2\n#&gt;   ..$ : chr [1:25] \"ALB\" \"AUT\" \"BEL\" \"BGR\" ...\n#&gt;   ..$ : chr [1:25] \"ALB\" \"AUT\" \"BEL\" \"BGR\" ...\nmatdis[1:10,1:5]\n#&gt;           ALB       AUT       BEL       BGR       CHE\n#&gt; ALB       0.0  836370.2 1542200.5  453144.9 1106855.4\n#&gt; AUT  836370.2       0.0  741690.6  992872.1  440155.5\n#&gt; BEL 1542200.5  741690.6       0.0 1734169.4  483933.6\n#&gt; BGR  453144.9  992872.1 1734169.4       0.0 1372828.3\n#&gt; CHE 1106855.4  440155.5  483933.6 1372828.3       0.0\n#&gt; CSK  919842.9  277453.7  860114.5  942990.5  685391.6\n#&gt; DDR 1317515.9  508033.5  553120.4 1372320.3  653897.6\n#&gt; DEU 1286962.2  454189.8  327639.9 1431684.2  407929.4\n#&gt; DNK 1775368.8  961323.9  652147.5 1804766.4  995146.1\n#&gt; ESP 1950211.4 1582434.4 1273370.9 2348013.0 1159491.1\n\nEt on calcule le pays le plus proche de tous les autres à l’aide de la fonction apply() (qu’on verra ultérieurement dans un autre chapitre)\n\nmean(matdis)\n#&gt; [1] 1262347\naccess&lt;-apply(matdis, FUN=mean,1)\naccess&lt;-access[order(access)]\nround(access,0)\n#&gt;     DEU     AUT     DDR     LUX     CSK     CHE     BEL     NLD     HUN     POL \n#&gt;  898957  926937  932604  944407  954421  966312  981428  984509 1043514 1062733 \n#&gt;     ITA     DNK     FRA     YUG     GBR     ROU     ALB     BGR     GRC     IRL \n#&gt; 1095500 1105659 1125130 1133254 1301552 1309032 1348834 1450710 1558508 1559733 \n#&gt;     SWE     NOR     ESP     FIN     PRT \n#&gt; 1592972 1692199 1701144 1923979 1964658"
  },
  {
    "objectID": "03-Base.html#exploration-i-var.-quali.",
    "href": "03-Base.html#exploration-i-var.-quali.",
    "title": "3  R-Base",
    "section": "3.2 Exploration I (var. quali.)",
    "text": "3.2 Exploration I (var. quali.)\n\n3.2.1 Sélection et recodage\nLes variables qualitatives nominales ou factor sont des objets composés d’une liste de numéros et d’une liste d’étiquettes.\n\n# Chargement du tableau de données\ndon &lt;- read.table(file = \"resources/data/europe88/euro1988.csv\", # nom du fichier et chemin d'accès\n                  sep = \";\",                     # séparateur (ici, des points-virgule)\n                  header = TRUE,                 # ligne d'en-tête avec le nom des variables\n                  encoding=\"UTF-8\")              # encodage adapté au français\n\n# Extraction de la variable\nX&lt;-don$BLOC\nX\n#&gt;  [1] \"Soc\" \"Cap\" \"Cap\" \"Soc\" \"Cap\" \"Soc\" \"Soc\" \"Cap\" \"Cap\" \"Cap\" \"Cap\" \"Cap\"\n#&gt; [13] \"Cap\" \"Cap\" \"Soc\" \"Cap\" \"Cap\" \"Cap\" \"Cap\" \"Cap\" \"Soc\" \"Cap\" \"Soc\" \"Cap\"\n#&gt; [25] \"Soc\"\n\n# Vérification du type\nstr(X)\n#&gt;  chr [1:25] \"Soc\" \"Cap\" \"Cap\" \"Soc\" \"Cap\" \"Soc\" \"Soc\" \"Cap\" \"Cap\" \"Cap\" ...\n\nSi la variable chargée est de type character il faut la transformer avec as.factor() et repérer les niveaux disponibles avec levels()\n\nX&lt;-as.factor(X)\nclass(X)\n#&gt; [1] \"factor\"\nlevels(X)\n#&gt; [1] \"Cap\" \"Soc\"\n\nOn peut remplacer les niveaux en utilisant l’instruction levels()à nouveau, mais suivie d’un vecteur de charactères indiquant les changements de nom.\n\n\nlevels(X)&lt;-c(\"Capitaliste\",\n             \"Socialiste\")\nX\n#&gt;  [1] Socialiste  Capitaliste Capitaliste Socialiste  Capitaliste Socialiste \n#&gt;  [7] Socialiste  Capitaliste Capitaliste Capitaliste Capitaliste Capitaliste\n#&gt; [13] Capitaliste Capitaliste Socialiste  Capitaliste Capitaliste Capitaliste\n#&gt; [19] Capitaliste Capitaliste Socialiste  Capitaliste Socialiste  Capitaliste\n#&gt; [25] Socialiste \n#&gt; Levels: Capitaliste Socialiste\nstr(X)\n#&gt;  Factor w/ 2 levels \"Capitaliste\",..: 2 1 1 2 1 2 2 1 1 1 ...\n\nOn peut transformer une variable quantitative en facteur avec la fonction cut()\n\nY&lt;-cut(don$POP, breaks=c(0,10,30,100))\nY\n#&gt;  [1] (0,10]   (0,10]   (0,10]   (0,10]   (0,10]   (10,30]  (10,30]  (30,100]\n#&gt;  [9] (0,10]   (30,100] (0,10]   (30,100] (30,100] (10,30]  (10,30]  (0,10]  \n#&gt; [17] (30,100] (0,10]   (10,30]  (0,10]   (30,100] (10,30]  (10,30]  (0,10]  \n#&gt; [25] (10,30] \n#&gt; Levels: (0,10] (10,30] (30,100]\nstr(Y)\n#&gt;  Factor w/ 3 levels \"(0,10]\",\"(10,30]\",..: 1 1 1 1 1 2 2 3 1 3 ...\n\nOn peut ensuite recoder les classes avec levels()\n\nlevels(Y)&lt;-c(\"Petit\",\"Moyen\",\"Grand\")\nY\n#&gt;  [1] Petit Petit Petit Petit Petit Moyen Moyen Grand Petit Grand Petit Grand\n#&gt; [13] Grand Moyen Moyen Petit Grand Petit Moyen Petit Grand Moyen Moyen Petit\n#&gt; [25] Moyen\n#&gt; Levels: Petit Moyen Grand\nstr(Y)\n#&gt;  Factor w/ 3 levels \"Petit\",\"Moyen\",..: 1 1 1 1 1 2 2 3 1 3 ...\n\n\n\n3.2.2 Table de dénombrement\nPour dénomber une variable qualitative, on utilise l’instruction table() qui crée un objet particulier qui n’est ni un data.frame, ni une matrix.\n\ntab&lt;-table(X)\ntab\n#&gt; X\n#&gt; Capitaliste  Socialiste \n#&gt;          17           8\nstr(tab)\n#&gt;  'table' int [1:2(1d)] 17 8\n#&gt;  - attr(*, \"dimnames\")=List of 1\n#&gt;   ..$ X: chr [1:2] \"Capitaliste\" \"Socialiste\"\n\nOn peut créer des tables à 2, 3 ou 4 dimensions\n\ntab2&lt;-table(X,Y)\ntab2\n#&gt;              Y\n#&gt; X             Petit Moyen Grand\n#&gt;   Capitaliste     9     3     5\n#&gt;   Socialiste      2     5     1\nstr(tab2)\n#&gt;  'table' int [1:2, 1:3] 9 2 3 5 5 1\n#&gt;  - attr(*, \"dimnames\")=List of 2\n#&gt;   ..$ X: chr [1:2] \"Capitaliste\" \"Socialiste\"\n#&gt;   ..$ Y: chr [1:3] \"Petit\" \"Moyen\" \"Grand\"\n\nUn objet de type table peut être manipulé par des fonctions spéciales comme addmargins() quii rajoute des sommes en ligne (et en colonne si la table est de dimension 2)\n\naddmargins(tab)\n#&gt; X\n#&gt; Capitaliste  Socialiste         Sum \n#&gt;          17           8          25\naddmargins(tab2)\n#&gt;              Y\n#&gt; X             Petit Moyen Grand Sum\n#&gt;   Capitaliste     9     3     5  17\n#&gt;   Socialiste      2     5     1   8\n#&gt;   Sum            11     8     6  25\n\n\n\n\n\n\n\nNote\n\n\n\nLes objets de type table sont souvent la source de crises de nerf de la part des étudiants qui les confondent avec des objets de type vecteur, matrice ou data.frame. Il existe des fonctions de conversion d’un type vers un autre mais leur emploi n’est pas très simple.\nOn retiendra donc dans l’immédiat que les résultats de l’instruction tablesont des objets transitoires qui servent uniquement à afficher des résultats ou produire des graphiques à l’aide des instructions plot() ou barplot().\n\n\n\n\n3.2.3 Graphique avec plot()\nLa fonction plot() s’applique à la plupart de objets R. Elle produit des résultats différents selon le type d’objet qu’elle a identifié. Si on l’applique à un vecteur de type factor on obtient un diagramme en bâtons (à ne pas confondre avec un histogramme)\n\nplot(X)\n\n\n\n\nOn peut améliorer le graphique en lui ajoutant des paramètres c’est-à-dire des instructions séparées par des virgules. Le retour à la ligne après chaque paramètre n’est pas obligatoire mais il est recommandé car il rend le code plus clair.\n\nplot(X,\n     col=c(\"blue\",\"red\"), \n     main= \"Europe en 1988\",\n     xlab = \"Type politique\", \n     ylab = \"Nombre de pays\")"
  },
  {
    "objectID": "03-Base.html#exploration-ii-var.-quanti",
    "href": "03-Base.html#exploration-ii-var.-quanti",
    "title": "3  R-Base",
    "section": "3.3 Exploration II (var. quanti)",
    "text": "3.3 Exploration II (var. quanti)\n\n3.3.1 Résumés numériques\nUne variable numérique peut faire l’objet d’un ensemble de résumés statistiques à l’aide de fonctions élémentaires\n\nmin() : minimum\nmax() : maximum\nmean() : moyenne\nsd() : écart-type (en anglais : standard deviation, soit sd en abrégé)\nsum() : somme\n\n\nX &lt;- don$FEC\nmin(X)\n#&gt; [1] 1.4\nmax(X)\n#&gt; [1] 3.3\nmean(X)\n#&gt; [1] 1.816\nsd(X)\n#&gt; [1] 0.4160128\n\nPour calculer les quantiles on peut utiliser la fonction quantile() en paramétrant la valeur de fréquence cumulée ascendante\n\nquantile(X,0) : minimum\nquantile(X,0.10) : D1 (premier décile)\nquantile(X,0.25) : Q1 (premier quartile)\nquantile(X,0.5) : Q2 (médiane)\nquantile(X,0.75) : Q3 (troisième quartile)\nquantile(X,0.90) : D9 (dernier décile)\nquantile(X,1) : maximum\n\n\nX&lt;-don$FEC\nquantile(X,0.5)\n#&gt; 50% \n#&gt; 1.7\nsel&lt;-c(0,0.25,0.5,0.75,1)\nquantile(X,sel)\n#&gt;   0%  25%  50%  75% 100% \n#&gt;  1.4  1.5  1.7  2.0  3.3\nsel&lt;-c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)\nquantile(X,sel)\n#&gt;   0%  10%  20%  30%  40%  50%  60%  70%  80%  90% 100% \n#&gt; 1.40 1.44 1.50 1.60 1.70 1.70 1.80 1.80 2.02 2.26 3.30\n\nIl peut arriver qu’une fonction soit manquante dans R, comme par exemple le coefficient de variation. Dans ce cas, on peut faire le calcul par des lignes de code ou créer sa propre fonction avec l’instruction function(). La fonction qui est stockée en mémoire apparaît dans la fenêtre Environnement. Lorsqu’on a créé plusieurs fonctions, on peut en faire un programme R qu’on charge en mémoire au début de chaque session. A plus long terme, on peut en faire un package qu’on partagera avec les autres utilisateurs de R.\nA titre d’exemple, nous créons une fonction cv() qui calcule le rapport entre l’écart-type et la moyenne d’une distribution :\n\n# lignes de code\nX &lt;- don$FEC\nsd(X)/mean(X)\n#&gt; [1] 0.2290819\n\n# fonction\ncv&lt;-function(var) {sd(var)/mean(var)}\ncv(X)\n#&gt; [1] 0.2290819\n\n\n\n3.3.2 Dénombrement\nUne variable quantitative peut être discrétisée avec cut(). Elle devient alors un facteur qu’on peut dénomber avec table() puis visualiseer avec plot() sous la forme de diagramme en bâtons.\n\nX&lt;-cut(don$FEC, c(1,1.5,2,2.5,3,3.5))\nstr(X)\n#&gt;  Factor w/ 5 levels \"(1,1.5]\",\"(1.5,2]\",..: 5 1 1 2 1 2 2 1 1 2 ...\ntable(X)\n#&gt; X\n#&gt; (1,1.5] (1.5,2] (2,2.5] (2.5,3] (3,3.5] \n#&gt;       7      13       4       0       1\n\n\nplot(X, col=c(\"green\",\"yellow\",\"orange\",\"red\",\"brown\"),\n     main = \"Fécondité en Europe en 1988\", xlab = \"classes\")\n\n\n\n\n\n\n3.3.3 Boîte à moustaches\nLa fonction boxplot() permet de visualiser une distribution sous forme de boîte à moustache où l’on repère facilement :\n\nla médiane\nles quartiles Q1 et Q3\nle minimum et le maximum\nles valeurs extrêmes situées à une distance supéreiure à 1.5 x (Q3-Q1) de la médiane\n\nLa syntaxe de base est la suivante :\n\nX&lt;-don$FEC\nboxplot(X)\n\n\n\n\nMais on peut améliorer la figure avec quelques paramètres de plus\n\nboxplot(X,horizontal = TRUE, col = \"gray80\",\n        main = \"Fécondité des pays européens en 1988\",\n        xlab = \"nb. enfants par femme\")\n\n\n\n\nEt on peut retirer les valeurs exceptionnelles avec le paramètre outline=FALSE\n\nboxplot(X,horizontal = TRUE, col = \"gray80\",\n        main = \"Fécondité des pays européens en 1988\",\n        xlab = \"nb. enfants par femme\",\n        outline = FALSE)\n\n\n\n\n\n\n3.3.4 Histogramme\nDans le cas d’une variable quantitative continue, la visualisation la plus logique est l’histogramme que l’on peut tracer avec la fonction hist(). Celle-ci comporte de nombreux paramètres que l’on peut visualiser dans la fenêtre Help qui se trouve en bas à gauche de R-studio :\nComme d’hebitude, on peut appliquer la syntaxe la plus simple :\n\nX&lt;-don$FEC\nhist(X)\n\n\n\n\nOn peut ensuite améliorer avec l’ajout de titres et un choix précis de classes. Dans le cas de la fécondité, il est par exemple important d’utiliser le seuil de 2.1 enfants par femme qui correspond au renouvellement des générations. On remarque que si les classes sont d’amplitudes inégales R utilise la densité de probabilité (rapport entre effectif et amplitude de la classe) et non plus l’effectif ce qui est statistiquement correct (et que ne fait pas Excel …).\n\nhist(X, \n     breaks = c(1.2, 1.5, 1.8, 2.1, 2.4, 3.3), \n     col=c(\"blue\", \"lightblue\",\"lightyellow\",\"orange\",\"red\"),\n     main = \"Fécondité des pays européens en 1988\",\n     ylab = \"Densité de probabilité\", \n     xlab = \"Nombre d'enfants par femme\",\n     xlim=c(1,3.5))\n\n\n\n\nOn peut également ajouter une courbe lissée de la distribution avec les fonctions lines() etdensity()en indiquant la portée du lissage à l'aide du paramètrebw`(band width) qui est exprimé dans l’unité de mesure de X\n\nhist(X, \n     breaks = c(1.2, 1.5, 1.8, 2.1, 2.4, 3.3),\n     col=c(\"blue\", \"lightblue\",\"green\",\"yellow\",\"orange\"),\n     main = \"Fécondité des pays européens en 1988\",\n     ylab = \"Densité de probabilité\", \n     xlab = \"Nombre d'enfants par femme\",\n     xlim=c(1,3.5))\nlines(density(X,bw=0.3),col=\"red\",lwd=2)"
  },
  {
    "objectID": "03-Base.html#exploration-iii-2-variables",
    "href": "03-Base.html#exploration-iii-2-variables",
    "title": "3  R-Base",
    "section": "3.4 Exploration III (2 variables)",
    "text": "3.4 Exploration III (2 variables)\nNous verrons en détail dans les chapitres suivants comment croiser deux variables d’un point de vue statistiques. Mais on peut déjà indiquer brièvement comment les visualiser rapidement à l’aide de trois exemples\n\n3.4.1 Deux variables qualitatives\n\nTableau de contingence\n\n\nX &lt;- don$BLOC\nlevels(X)&lt;-c(\"Capitalise\",\"Socialiste\")\nY&lt;-cut(don$POP, breaks=c(0,10,30,100))\nlevels(Y) &lt;- c(\"petit\",\"moyen\",\"grand\")\ntab&lt;-table(X,Y)\naddmargins(tab)\n#&gt;      Y\n#&gt; X     petit moyen grand Sum\n#&gt;   Cap     9     3     5  17\n#&gt;   Soc     2     5     1   8\n#&gt;   Sum    11     8     6  25\n\n\nGraphique\n\n\nplot(tab, col=c(\"yellow\",\"orange\",\"brown\"))\n\n\n\n\n\nTest (Chi-2)\n\n\ntest&lt;-chisq.test(X,Y)\n#&gt; Warning in chisq.test(X, Y): Chi-squared approximation may be incorrect\ntest\n#&gt; \n#&gt;  Pearson's Chi-squared test\n#&gt; \n#&gt; data:  X and Y\n#&gt; X-squared = 5.0336, df = 2, p-value = 0.08072\n\n\n\n3.4.2 Deux variables quantitatives\n\nParamètres principaux\n\n\nY &lt;- don$TMI\nX&lt;-don$PNB\nsummary(X)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;     600    2300    8600    7580   12000   17800\nsummary(Y)\n#&gt;    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#&gt;    5.80    8.50    9.70   12.99   14.50   43.00\n\n\nGraphique\n\n\nplot(X,Y, xlab=\"PNB par habitant\",ylab=\"Mortalité infantile\")\ntext(X,Y,don$PAYS,pos = 4,cex=0.6)\n\n\n\n\n\nTest (Pearson)\n\n\ncor.test(Y,X)\n#&gt; \n#&gt;  Pearson's product-moment correlation\n#&gt; \n#&gt; data:  Y and X\n#&gt; t = -4.1955, df = 23, p-value = 0.0003459\n#&gt; alternative hypothesis: true correlation is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  -0.8360497 -0.3558907\n#&gt; sample estimates:\n#&gt;        cor \n#&gt; -0.6584308\n\n\n\n3.4.3 Une quantitative et une qualitative\n\nGraphique\n\n\nY &lt;- don$TMI\nX &lt;- as.factor(don$BLOC)\nlevels(X)&lt;-c(\"Capitalise\",\"Socialiste\")\nplot(X,Y, \n     col=c(\"blue\",\"red\"),\n     xlab =\"Mortalité infantile\",\n     ylab = \"Bloc politique\",\n     horizontal=T)\n\n\n\n\n\nTest (Fischer)\n\n\nmod&lt;-aov(Y~X)\nsummary(mod)\n#&gt;             Df Sum Sq Mean Sq F value   Pr(&gt;F)    \n#&gt; X            1  797.4   797.4   20.85 0.000137 ***\n#&gt; Residuals   23  879.7    38.2                     \n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "03-Base.html#en-résumé",
    "href": "03-Base.html#en-résumé",
    "title": "3  R-Base",
    "section": "3.5 En résumé",
    "text": "3.5 En résumé\n\n\n\nNous avons survolé les principales fonctions élémentaires de R-Base pour montrer qu’il est facile et surtout rapide de les employer en lieu et place d’un tableur comme Excel ou d’un logiciel de statistique click-bouton. Il reste encore beaucoup à apprendre mais à ce stade il est important de bien consolider les acquis et de connaître par coeur le nom des principales fonctions de base qui ont été présentées au cours de ce chapitre."
  },
  {
    "objectID": "22-ressources.html#tbd",
    "href": "22-ressources.html#tbd",
    "title": "Annexe A — Ressources",
    "section": "A.1 tbd",
    "text": "A.1 tbd"
  }
]